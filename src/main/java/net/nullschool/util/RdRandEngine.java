package net.nullschool.util;

import javax.crypto.spec.SecretKeySpec;
import java.io.IOException;
import java.security.Key;

import static net.nullschool.util.EngineTools.hashSHA256;
import static net.nullschool.util.EngineTools.loadRdRandNativeLibrary;


/**
 * 2013-02-02<p/>
 *
 * An implementation of DigitalRandomSpi that uses {@code rdrand} instructions to generate randomness.
 * See <a href="http://en.wikipedia.org/wiki/RdRand">wikipedia</a>. This implementation uses a native
 * library, embedded as a resource in the .jar, to invoke {@code rdrand} directly. Due to system constraints
 * the native library resource is first copied to the temp directory specified by the system property
 * {@code java.io.tmpdir} and then loaded. If the copy or load fails, or if the processor does not support
 * {@code rdrand}, then instantiation of this class will throw an {@link UnsupportedOperationException}.<p/>
 *
 * Released to the public domain: http://creativecommons.org/publicdomain/zero/1.0/
 *
 * @author Cameron Beccario
 */
final class RdRandEngine extends DigitalRandomSpi {

    private static volatile boolean isSupported;  // flag to remember is CPU supports rdrand
    private static volatile boolean isLinked;     // flag to remember if native library has been loaded
    private static final Object lock = new Object();

    /**
     * Extract the native library to a temp directory and load it. If successful, subsequent calls
     * return immediately. If not successful, subsequent calls will attempt another extract and load
     * operation.
     *
     * @throws IOException if extraction fails for any reason or the load failed.
     * @see System#load(String)
     */
    private static void link() throws IOException {
        synchronized (lock) {
            if (!isLinked) {
                loadRdRandNativeLibrary();
                isLinked = true;
            }
        }
    }

    /**
     * Returns true if the CPU supports the {@code rdrand} instruction.
     */
    private static native boolean isRdRandSupported();

    /**
     * Load the native library and query the CPU for {@code rdrand} instruction support. If successful,
     * subsequent calls return true immediately.
     */
    static boolean linkAndCheckRdRandSupported() {
        if (isSupported) {
            return true;
        }
        try {
            link();
            return isSupported = isRdRandSupported();
        }
        catch (Throwable t) {
            throw new UnsupportedOperationException(
                "Random number generation using rdrand is not supported because engine initialization failed.",
                t);
        }
    }


    RdRandEngine() throws UnsupportedOperationException {
        if (!linkAndCheckRdRandSupported()) {
            throw new UnsupportedOperationException(
                "Random number generation using rdrand is not supported by this CPU.");
        }
    }

    /**
     * Intel's DRNG implementation does not support setting a seed.
     *
     * @throws UnsupportedOperationException always
     */
    @Override protected void engineSetSeed(byte[] seed) {
        throw new UnsupportedOperationException();
    }

    /**
     * {@inheritDoc}
     *
     * @return random value generated by rdrand
     */
    @Override protected native int engineNextInt();

    /**
     * {@inheritDoc}
     *
     * @return random value generated by rdrand
     */
    @Override protected native long engineNextLong();

    /**
     * {@inheritDoc}
     *
     * @param bytes the array to fill with random data generated by rdrand
     */
    @Override protected native void engineNextBytes(byte[] bytes);

    private byte[] nextBytes(byte[] bytes) {
        engineNextBytes(bytes);
        return bytes;
    }

    /**
     * {@inheritDoc}<p/>
     *
     * This implementation relies on the knowledge that Intel guarantees the hardware DRNG reseeds
     * itself at least every 1024 64-bit samples (8192 bytes), although in practice reseeding occurs
     * much more often. This method hashes a 8192 byte sample using SHA256 to generate 32 bytes of
     * distilled seed entropy. If more seed data is required, the process is repeated. The hash
     * function is initialized with a random 128-bit key as provided by {@link #engineNextBytes(byte[])}.
     */
    @Override protected byte[] engineGenerateSeed(int numBytes) {
        byte[] seed = new byte[numBytes];
        byte[] sample = new byte[8192];  // Large enough to guarantee hardware reseed.
        final Key key = new SecretKeySpec(nextBytes(new byte[16]), "None");

        int written = 0, size;
        while (written < seed.length) {
            // Hash a large amount of random data.
            byte[] hash = hashSHA256(key, nextBytes(sample));
            // Use the hash as seed data.
            System.arraycopy(hash, 0, seed, written, size = Math.min(hash.length, seed.length - written));
            // Repeat until we have enough seed data.
            written += size;
        }
        return seed;
    }


    private static final long serialVersionUID = 1;
}
